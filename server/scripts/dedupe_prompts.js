#!/usr/bin/env node
// scripts/dedupe_prompts.js
// Skeleton dedupe script for Phase 4. This script should be safe to run in
// dry-run mode and must be tested on a staging snapshot before applying to any
// real data.

const { PrismaClient } = require("@prisma/client");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const normalizePrompt = require("../utils/normalizePrompt");

async function run({
  dryRun = true,
  apply = false,
  backup = false,
  backupDir,
} = {}) {
  const prisma = new PrismaClient();
  try {
    console.log(
      "Starting dedupe (dryRun=%s, apply=%s, backup=%s)",
      dryRun,
      apply,
      backup
    );
    const prompts = await prisma.prompt.findMany({
      orderBy: { createdAt: "asc" },
    });
    const map = new Map();
    for (const p of prompts) {
      const norm = normalizePrompt(p.prompt || "");
      const hash = crypto.createHash("sha256").update(norm).digest("hex");
      if (!map.has(hash)) map.set(hash, []);
      map.get(hash).push(p);
    }

    let totalDuplicates = 0;
    const plannedActions = [];

    for (const [hash, group] of map.entries()) {
      if (group.length <= 1) continue;
      totalDuplicates += group.length - 1;
      // keep earliest createdAt as canonical
      group.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
      const canonical = group[0];
      const duplicates = group.slice(1);

      console.log(
        `Found ${group.length} duplicates for hash ${hash}:`,
        group.map((x) => x.id)
      );

      plannedActions.push({ hash, canonical, duplicates });
    }

    console.log("Total duplicate prompt rows found:", totalDuplicates);

    if (plannedActions.length === 0) {
      console.log("No duplicate groups found. Exiting.");
      return { applied: false, planned: 0 };
    }

    // If just preview/dry-run, print planned SQL actions and return
    if (dryRun || !apply) {
      console.log("DRY RUN — Planned actions (no DB changes):");
      for (const act of plannedActions) {
        const dupIds = act.duplicates.map((d) => d.id);
        console.log(
          `- Hash ${act.hash}: keep ${act.canonical.id}, reassign ai_results from [${dupIds}] -> ${act.canonical.id} and delete prompts [${dupIds}]`
        );
      }
      return { applied: false, planned: plannedActions.length };
    }

    // At this point apply === true
    if (apply && !backup) {
      console.warn(
        "Applying without backups is discouraged. Re-run with --backup to create backups before applying, or pass --confirm if you understand the risk."
      );
      throw new Error(
        "Refusing to apply without --backup. Run again with --backup to produce backups before applying."
      );
    }

    // Ensure backupDir
    const outDir =
      backupDir || path.join(__dirname, "../../server/tmp-dedupe-backups");
    fs.mkdirSync(outDir, { recursive: true });

    // Apply each group: backup, reassign ai_results, delete prompt rows
    for (const act of plannedActions) {
      const dupIds = act.duplicates.map((d) => d.id);
      // fetch ai_results for duplicates
      const aiResults = await prisma.aIResult.findMany({
        where: { promptId: { in: dupIds } },
      });

      // Write backup files: JSON and SQL
      const safeHash = act.hash.slice(0, 12);
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const jsonPath = path.join(
        outDir,
        `dedupe-${safeHash}-${timestamp}.json`
      );
      const sqlPath = path.join(outDir, `dedupe-${safeHash}-${timestamp}.sql`);

      const backupObj = {
        hash: act.hash,
        canonical: act.canonical,
        duplicates: act.duplicates,
        aiResults,
      };
      fs.writeFileSync(jsonPath, JSON.stringify(backupObj, null, 2), "utf8");

      // Build SQL insert statements for the backed up rows (prompts + ai_results)
      const sqlLines = [];
      sqlLines.push(
        `-- Backup generated by dedupe_prompts.js for hash ${
          act.hash
        } at ${new Date().toISOString()}`
      );
      // prompts
      for (const row of [act.canonical, ...act.duplicates]) {
        const cols = Object.keys(row)
          .map((c) => `"${c}"`)
          .join(", ");
        const vals = Object.keys(row)
          .map((c) => {
            const v = row[c];
            if (v === null || v === undefined) return "NULL";
            if (v instanceof Date) return `'${v.toISOString()}'`;
            return `'${String(v).replace(/'/g, "''")}'`;
          })
          .join(", ");
        sqlLines.push(`INSERT INTO prompt (${cols}) VALUES (${vals});`);
      }
      // aiResults
      for (const ar of aiResults) {
        const obj = Object.assign({}, ar);
        // stringify JSON column(s)
        if (obj.result && typeof obj.result !== "string")
          obj.result = JSON.stringify(obj.result);
        const cols = Object.keys(obj)
          .map((c) => `"${c}"`)
          .join(", ");
        const vals = Object.keys(obj)
          .map((c) => {
            const v = obj[c];
            if (v === null || v === undefined) return "NULL";
            if (v instanceof Date) return `'${v.toISOString()}'`;
            return `'${String(v).replace(/'/g, "''")}'`;
          })
          .join(", ");
        sqlLines.push(`INSERT INTO a_i_result (${cols}) VALUES (${vals});`);
      }
      fs.writeFileSync(sqlPath, sqlLines.join("\n"), "utf8");

      // Perform DB updates inside a transaction
      console.log(
        `Applying changes for hash ${act.hash}: reassigning ${aiResults.length} ai_results and deleting prompts [${dupIds}]`
      );
      await prisma.$transaction([
        prisma.aIResult.updateMany({
          where: { promptId: { in: dupIds } },
          data: { promptId: act.canonical.id },
        }),
        prisma.prompt.deleteMany({ where: { id: { in: dupIds } } }),
      ]);

      console.log(
        `Applied group ${act.hash} — backups written to: ${jsonPath} and ${sqlPath}`
      );
    }

    return { applied: true, planned: plannedActions.length };
  } finally {
    try {
      await prisma.$disconnect();
    } catch (e) {}
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  const apply = args.includes("--apply");
  const backup = args.includes("--backup");
  const dryRun = args.includes("--no-dry-run") ? false : !apply;
  const bdIndex = args.indexOf("--backup-dir");
  const backupDir = bdIndex >= 0 ? args[bdIndex + 1] : undefined;

  if (apply && !args.includes("--confirm") && !backup) {
    console.error(
      "To apply changes you must pass --apply --backup, or pass --confirm to proceed without a backup.\nRecommended: --apply --backup --confirm"
    );
    process.exit(2);
  }

  const runOpts = { dryRun, apply, backup };
  if (backupDir) runOpts.backupDir = backupDir;

  run(runOpts).catch((err) => {
    console.error("dedupe script failed", err);
    process.exit(1);
  });
}

module.exports = { run };
